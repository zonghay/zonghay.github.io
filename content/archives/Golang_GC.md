---
title: "Golang GC"
date: 2025-04-03T15:58:34+08:00
lastmod: 2025-04-03T15:58:34+08:00
author: ["ZhangYong"]
tags: # 标签
- ALL
- Golang
description: ""
weight:
slug: ""
draft: false # 是否为草稿
comments: true # 本页面是否显示评论
mermaid: true #是否开启mermaid
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hideMeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
hideSummary: false
ShowWordCount: true
ShowBreadCrumbs: true #顶部显示路径
cover:
    image: "" #图片路径例如：posts/tech/123/123.png
    zoom: # 图片大小，例如填写 50% 表示原图像的一半大小
    caption: "" #图片底部描述
    alt: ""
    relative: false
---

标记清理
从根节点遍历可达的所有对象标记为存活状态
遍历堆中的所有对象，释放没有被标记的内存空间
用户程序在垃圾收集的过程中不能执行(STW)

三色抽象
白色-潜在垃圾，其内存可能被GC回收
黑色-活跃对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象
灰色-活跃对象，因为存在指向白色对象的外部指针，GC会扫描这些对象的子对象

在垃圾收集器开始工作时，程序中不存在任何的黑色对象，垃圾收集的根对象会被标记成灰色，垃圾收集器只会从灰色对象集合中取出对象开始扫描，当灰色集合中不存在任何对象时，标记阶段就会结束。

三色标记垃圾收集器的工作原理很简单，我们可以将其归纳成以下几个步骤：
1. 从灰色对象的集合中选择一个灰色对象并将其标记成黑色；
2. 将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收；
3. 重复上述两个步骤直到对象图中不存在灰色对象；


屏障技术

垃圾收集中的屏障技术更像是一个钩子方法，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，根据操作类型的不同，我们可以将它们分成读屏障（Read barrier）和写屏障（Write barrier）两种，因为读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，所以编程语言往往都会采用写屏障保证三色不变性。

我们在这里想要介绍的是 Go 语言中使用的两种写屏障技术，分别是 Dijkstra 提出的插入写屏障8和 Yuasa 提出的删除写屏障9，这里会分析它们如何保证三色不变性和垃圾收集器的正确性。

增量和并发

Go语言的垃圾收集器采用了增量和并发的方式来减少垃圾收集对程序性能的影响。

### 增量式垃圾收集

增量式垃圾收集将整个垃圾收集过程分解为多个小步骤，每次执行一部分工作，而不是一次性完成整个垃圾收集过程。这样可以将垃圾收集的停顿时间分散到整个程序执行过程中，减少单次停顿的时间。

增量式垃圾收集的主要优点是：
- 减少了单次垃圾收集的停顿时间
- 提高了程序的响应性
- 使垃圾收集的工作负载更加平均

### 并发垃圾收集

并发垃圾收集允许垃圾收集器与用户程序同时运行，只在必要的时刻短暂暂停用户程序。Go语言的垃圾收集器采用了并发标记和并发清除的策略。

Go的并发垃圾收集过程大致如下：
1. 初始标记阶段（STW）：标记根对象，这个阶段需要暂停程序（Stop The World）
2. 并发标记阶段：垃圾收集器与用户程序并发执行，标记所有可达对象
3. 重新标记阶段（STW）：处理并发标记阶段中由于用户程序继续运行导致的对象引用变化
4. 并发清除阶段：清除未标记的对象，与用户程序并发执行

### 触发时机

Go语言的垃圾收集器会在以下情况触发：
1. 内存分配达到阈值时自动触发
2. 当前内存分配达到上次垃圾收集后的内存分配量的一定比例（默认为100%）
3. 通过调用`runtime.GC()`手动触发
4. 系统定期触发（默认2分钟）

### 性能调优

Go提供了一些环境变量和运行时参数来调整垃圾收集器的行为：
- `GOGC`：控制垃圾收集的触发频率，默认值为100，表示当内存增长到上次垃圾收集后的两倍时触发垃圾收集
- `GOMEMLIMIT`：限制Go程序的内存使用量（Go 1.19+）
- `debug.SetGCPercent()`：动态调整GOGC的值
- `debug.SetMemoryLimit()`：动态调整内存限制（Go 1.19+）

### 实际应用中的考量

在实际应用中，开发者需要注意以下几点来优化Go程序的垃圾收集性能：
1. 减少对象分配：尽量复用对象，避免不必要的内存分配
2. 使用对象池：对于频繁创建和销毁的对象，可以使用`sync.Pool`来减少垃圾收集的压力
3. 避免内存泄漏：确保不再使用的大对象的引用被及时清除
4. 合理设置GOGC：根据应用的特性调整垃圾收集的触发频率
5. 监控垃圾收集指标：使用`runtime/debug`包或者性能分析工具监控垃圾收集的行为

## 总结

Go语言的垃圾收集器采用了三色标记法、写屏障技术、增量式和并发垃圾收集等多种技术，在保证内存安全的同时，尽可能减少对程序性能的影响。通过不断的优化，Go语言的垃圾收集器已经能够在大多数应用场景下提供良好的性能表现。

理解Go语言垃圾收集器的工作原理和优化技巧，对于编写高性能的Go程序至关重要。

## 参考
[垃圾收集器](https://draven.co/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#72-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8)         
[Go GC: Prioritizing low latency and simplicity](https://go.dev/blog/go15gc)            
[Getting to Go: The Journey of Go's Garbage Collector](https://go.dev/blog/ismmkeynote)